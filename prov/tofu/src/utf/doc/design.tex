\section{Design}

最大プロセス数は、663,552 (24x24x24x12x4)とする。

受信側と送信側で一貫した状態を管理する必要がある。

%==============================================================================
\subsection{データ構造}
%==============================================================================
%------------------------------------------------------------------------------
\subsubsection{メッセージ構造体}
%------------------------------------------------------------------------------
MPIのRequest構造体に対応するUTFにおける構造体。
\begin{itemize}
\item struct utf\_msgreq: ユーザメッセージの管理 defined in utf\_queue.h
\item struct utf\_msglst: 上記構造体のリスト
\end{itemize}

%------------------------------------------------------------------------------
\subsubsection{受信領域}
%------------------------------------------------------------------------------
\begin{itemize}
\item strutc erecv\_buf: 受信バッファ定義 defined in utf\_queue.h\\
  \begin{lstlisting}[frame=single]
  struct erecv_buf {
    union {
	uint64_t cntr;
	char	 pad[256];
    } header;
    char	rbuf[MSG_SIZE*MSG_PEERS];
  };
  \end{lstlisting}
\item utofu\_stadd\_t erbstadd: 上記のstaddを保持。全プロセスで同じ値。
\end{itemize}
MSG\_PEERS分だけ同時に通信できる。

%------------------------------------------------------------------------------
\subsubsection{送信情報情報}
%------------------------------------------------------------------------------
\begin{itemize}
\item struct sndmgt: リモートノード情報管理 defined in utf\_sndmgt.h\\
  sndmgtは4バイトデータであり、全系では2.5MBのメモリ容量を消費する。
  現在、indexが6bitなので63エントリまでしか指せない。
\item struct utf\_send\_cntr: 送信情報 per receiver define in utf\_queue.h\\
  128バイト。linked list構造になる。サイズは同時に幾つの非同期送信を許すかに依存。
  SND\_EGR\_BUFENTで決まる。現在128。
\item uint16\_t rank2scntridx: remote rankからutf\_send\_cntr配列のindex値\\
  2バイトデータであり、全系では1.3MBのメモリ容量を消費する。
\item struct utf\_egr\_sbuf: struct utf\_msgbdyと同じ。defined in utf\_queue.h\\
  実体はutf\_egsbuf変数。サイズはSND\_EGR\_BUFENTで決まる。現在128。
  送信用バッファでありメモリレジストレーション済み。utf\_egrsbuf\_alloc関数で取り出される。
\end{itemize}

%==============================================================================
\subsection{送信}
%==============================================================================
%------------------------------------------------------------------------------
\subsubsection{送信制御用構造体の割当}
%------------------------------------------------------------------------------
送信制御用にsend\_cntrを割り当てる。ソースプログラム上usp変数で参照される。
utf\_scntr\_alloc関数(defined in utf\_mem.c) において割り当てる。現在
freeリストはbit管理しているが、これは当初、utf\_send\_cntr構造体を小さ
くするために配列インデックスでnextポインタを管理していた。構造体全体が
64バイトに収まらなくなりポインタのコンパクション必要なくなったので、
freeリスト管理の方が効率良い。今後修正。

ただし、リモートランクから構造体アドレスを取り出すrank2scntridx配列は
utf\_send\_cntr構造体のindexのままとしメモリ容量削減する。
プロトコル処理時においてもedataにindexを設定して処理をしている。
%------------------------------------------------------------------------------
\subsubsection{送信データバッファの割当}
%------------------------------------------------------------------------------
utf\_egrsbuf\_alloc関数でメモリ登録されているバッファ領域を確保する。
uspのsndbufメンバ変数にstaddが登録される。この領域は

%------------------------------------------------------------------------------
\subsubsection{メッセージ構造体の割当}
%------------------------------------------------------------------------------
utf\_msgreq\_alloc関数でutf\_msgreq構造体を割り当てる。これは受信側のposted/expected queue entryでもある。

%------------------------------------------------------------------------------
\subsubsection{送信タイプの決定およびデータコピー}
%------------------------------------------------------------------------------
メッセージサイズに応じて以下を選択。
\begin{itemize}
\item EAGER\\
  MSG\_EAGER\_SIZE以下のメッセージは、送信データバッファにコピーして即送信。
  cnrtypeはSNDCNTR\_BUFFERED\_EAGER。
\item RENDEZOUS\\
  それ以上の場合には以下の2つを提供。
  \begin{itemize}
  \item utf\_msgmodeがMSG\_RENDEZOUSの場合は、ランデブープロトコル。
    cnrtypeはSNDCNTR\_RENDEZOUS。
  \item そうでなければEAGER。 cnrtypeはSNDCNTR\_INPLACE\_EAGER。
    最初の送信用に送信データバッファにデータをコピー。
  \end{itemize}
\end{itemize}

%------------------------------------------------------------------------------
\subsubsection{送信スタート}
%------------------------------------------------------------------------------
remote buffer indexをsndmgtp求める。以下の変数はsndmgtp[dst]のメンバ変数。
\begin{enumerate}
\item examedでなければ、送信状態をS\_REQ\_ROOMにして、以下の処理を不可分に実行する（必要がある）。
  \begin{enumerate}
  \item remoteのerecv\_buf.cntrをremote incrementし、その結果が
    MSG\_SIZE以下であれば、examedおよびsndokをセット、indexにその値を入れる。
  \item MSG\_SIZE以上であれば、examedをセットするだけ。
  \end{enumerate}
  utf\_send\_start関数では、remoteオペレーションを発行するのみ。
  ここでexamedを設定しているけど駄目では。
  edataは送信制御用構造体配列のindexを指定。
\item examedかつsndokであれば、indexにremoteのbuffer indexが求めるindex。
  送信状態をS\_HAS\_ROOMにしてutf\_sendengineを呼び出す。
\item examedかつsndokでなければ、remoteのeager bufが枯渇している。
\end{enumerate}

%------------------------------------------------------------------------------
\subsubsection{送信プロトコルエンジン}
%------------------------------------------------------------------------------

\begin{itemize}
\item S\_REQ\_ROOM:\\
  send operationでremote bufferを取得するためにremote add命令を発行し
  た結果としてUTOF\_MRQ\_TYPE\_LCL\_ARMWイベントが発生する。このイベントが
  発生した時に、送信プロトコルエンジンが呼ばれる。この時状態はS\_REQ\_ROOM。
  sndmgtp[dst]に値を設定する。現状の実装ではremote bufferがoverflowしている
  時の対応が出来ていない。状態をS\_HAS\_ROOMに遷移する。
\item S\_HAS\_ROOM:\\
  cntrtypeに応じて処理が異なる。
  \begin{itemize}
  \item SNDCNTR\_BUFFERED\_EAGER:\\
    32byte以下の場合にはpiggysendし、そうでなければサイズ分だけ送る。
    libfabricの場合はMSG\_EAGER\_SIZE (1878 B) 分。
    MSG\_SIZEは1920 B、MSGBUF\_SIZEは19200 B、MSGBUF\_THRは9600 B
    状態をS\_DONE\_EGRにする。
  \item SNDCNTR\_INPLACE\_EAGER:\\
    送れるだけ送る。状態をS\_DO\_EGRにする。
  \item SNDCTR\_RENDEZOUS:\\
    ランデブープロトコル実装していないなあ。
  \end{itemize}
\item S\_DO\_EGR:\\
  残りを送る。
  受信側のバッファサイズは
\item S\_DONE\_EGR:\\
  状態をS\_FREEにする。メッセージ要求構造体の状態をREQ\_DONEにする。
  uspは使いまわしするように考えているがこれで大丈夫か？
\end{itemize}

%------------------------------------------------------------------------------
\subsubsection{eager bufが枯渇した場合}
%------------------------------------------------------------------------------

%==============================================================================
\subsection{受信}
%==============================================================================
%------------------------------------------------------------------------------
\subsubsection{受信プロトコルエンジン}
%------------------------------------------------------------------------------
受信プロトコルエンジンは、MRQイベントによって駆動される。
以下のイベントを使う。
\begin{itemize}
\item UTOFU\_MRQ\_TYPE\_RMT\_PUT:\\
  remoteからデータがputされた時、書かれたデータの最後のアドレスが
  rmt\_valueに格納されるので、この値からreceive bufferアドレスを求め、
  受信プロトコルエンジンを起動する。
\item UTOFU\_MRQ\_TYPE\_RMT\_ARMW:\\
  現在なにもしない。
\end{itemize}

受信プロトコルエンジン
\begin{itemize}
\item R\_NONE:\\
  最初。postedかunexpectedか調べる。
\item R\_BODY:\\
\end{itemize}


%==============================================================================
\subsection{メモリ管理}
%==============================================================================

%==============================================================================
\subsection{Trigger通信}
%==============================================================================

